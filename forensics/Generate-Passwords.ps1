function Generate-Password {
<#
.SYNOPSIS
This function generates any number of complex passwords. 

.DESCRIPTION
This function generates a user-supplied number of passwords (by default
generates a single password) of a specified length (default 15). The
generator creates passwords that use each of the four primary character 
types: uppercase letters, lowercase letter, numbers, and special character.
By default the password only generates passwords that repeat each 
characterset no more than two times. Later versions of this function may allow
for the user the set the maximum number of repeated character sets.

.PARAMETER Count
    Specify the number of passwords generated by this script. 

.PARAMETER Length
    User can specify the length of the password (default is 15)

.EXAMPLE
PS> Generate-Password

.EXAMPLE
PS> Generate-Password -Count 5 -Length 15

.EXAMPLE
PS> Generate-Password -Count 10 -Length 50

.EXAMPLE
PS> Generate-Password -Count 25 -Length 20 | Out-File "$HOMEDIR\Documents\passwords.csv"



.NOTES
Author: brx.cybr@gmail.com
Last Updated: 10/02/2020
#>
Param([int]$Count = 1, [int]$Length = 15)

function Check-ConsecutiveChars ($pw)
{
# Checks to make sure that each charset does not repeat more than two times

# Character sets
$uppers = 'A','B','C','D','E','F','G','H','K','L','M','N','O','P','R','S','T','U','V','W','X','Y','Z'
$lowers = 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','r','s','t','u','v','w','x','y','z'
$nums = '1','2','3','4','5','6','7','8','9','0'
$specials = '!','"','ยง','$','%','&','/','(',')','=','?','}',']','[','{','@','#','*','+'

# Initialize current letter variable
$cl = 0 

# Loop until it get to end of password
while ($cl -le ($pw.Length - 3)){
    if ((($pw[$cl] -cin $uppers) -And ($pw[$cl + 1] -cin $uppers) -And ($pw[$cl + 2] -cin $uppers)) -Or
       (($pw[$cl] -cin $lowers) -And ($pw[$cl + 1] -cin $lowers) -And ($pw[$cl + 2] -cin $lowers)) -Or 
       (($pw[$cl] -in $nums) -And ($pw[$cl + 1] -in $nums) -And ($pw[$cl + 2] -in $nums)) -Or
       (($pw[$cl] -in $specials) -And ($pw[$cl + 1] -in $specials) -And ($pw[$cl + 2] -in $specials))  
        ){ return $false }
     else {$cl += 1}
}
return $true
}


function Generate-RandomPassword ($pw_len) 
{
    If ($pw_len -lt 4) { $pw_len = 4 }   #Password must be at least 4 characters long in order to satisfy complexity requirements.

    #Use the .NET crypto random number generator, not the weaker System.Random class with Get-Random:
    $RngProv = [System.Security.Cryptography.RNGCryptoServiceProvider]::Create()
    [byte[]] $onebyte = @(255)
    [Int32] $x = 0

    Do {
        [byte[]] $password = @() 
        
        $hasupper =     $false    #Has uppercase letter character flag.
        $haslower =     $false    #Has lowercase letter character flag.
        $hasnumber =    $false    #Has number character flag.
        $hasnonalpha =  $false    #Has non-alphanumeric character flag.
        $isstrong =     $false    #Assume password is not complex until tested otherwise.
        
        For ($i = $pw_len; $i -gt 0; $i--)
        {                                                         
            While ($true)
            {   
                #Generate a random US-ASCII code point number.
                $RngProv.GetNonZeroBytes( $onebyte ) 
                [Int32] $x = $onebyte[0]                  
                if ($x -ge 32 -and $x -le 126){ break }   
            }
            
            # Even though it reduces randomness, eliminate problem characters to preserve sanity while debugging.
            # If you're worried, increase the length of the password or comment out the undesired line(s):
            If ($x -eq 32) { $x++ }    #Eliminates the space character; causes problems for other scripts/tools.
            If ($x -eq 34) { $x-- }    #Eliminates double-quote; causes problems for other scripts/tools.
            If ($x -eq 39) { $x-- }    #Eliminates single-quote; causes problems for other scripts/tools.
            If ($x -eq 47) { $x-- }    #Eliminates the forward slash; causes problems for net.exe.
            If ($x -eq 96) { $x-- }    #Eliminates the backtick; causes problems for PowerShell.
            If ($x -eq 48) { $x++ }    #Eliminates zero; causes problems for humans who see capital O.
            If ($x -eq 79) { $x++ }    #Eliminates capital O; causes problems for humans who see zero. 
            
            $password += [System.BitConverter]::GetBytes( [System.Char] $x ) 

            If ($x -ge 65 -And $x -le 90)  { $hasupper = $true }   #Non-USA users may wish to customize the code point numbers by hand,
            If ($x -ge 97 -And $x -le 122) { $haslower = $true }   #which is why we don't use functions like IsLower() or IsUpper() here.
            If ($x -ge 48 -And $x -le 57)  { $hasnumber = $true } 
            If (($x -ge 32 -And $x -le 47) -Or ($x -ge 58 -And $x -le 64) -Or ($x -ge 91 -And $x -le 96) -Or ($x -ge 123 -And $x -le 126)) { $hasnonalpha = $true } 
            If ($hasupper -And $haslower -And $hasnumber -And $hasnonalpha) { $isstrong = $true } 
        } 
    } While ($isstrong -eq $false)

    #$RngProv.Dispose() #Not compatible with PowerShell 2.0.

    ([System.Text.Encoding]::Unicode).GetString($password) #Make sure output is encoded as UTF16LE. 
}


# Initialize Password list
$pw_list = @()

# Loop until the password list contains the correct number of passwords
while ($pw_list.Length -lt $Count){
    
    # Get a password using the generator
    $pw = (Generate-RandomPassword ($Length))
    
    # Check to make sure that each charset does not repeat more than two times
    # If function returns true, append to password list
    if (Check-ConsecutiveChars ($pw)){$pw_list += $pw}
    }

# Write final list to the screen
$pw_list
     

}
